/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f407xx_gpio_driver.h"

/* Ejercicio: escribir un programa que haga parpadear un led
 * (usar los integrados de la placa), con cierto retardo.
 *
 * Primer caso: emplearemos una configuracion push-pull.
 * Segundo caso: emplearemos una configuracion open-drain.
 */

void ejercicio_1_configuracion_push_pull()
{
  /* Enables the module before configure, otherwise it won't work */
  GPIO_clock_enable_disable(GPIO_PORT_D, 1);

  /* Configure the GPIO port and pin. We're going to use a board's led,
   * so we need to see which port and pin are necessary. */
  GPIO_Initialization(GPIO_PORT_D, GPIO_PIN_12, GPIO_MODE_OUTPUT,
                         GPIO_NO_PULL_UP_DOWN, GPIO_OUTPUT_PUSH_PULL,
                         GPIO_SPEED_MEDIUM, GPIO_NON_ALTERNATE_FUNCTIONALITY,
                         0);
  /* Now, create a loop to blink the LED light with a sleep time between.
   * It's necessary to include a delay to see the LED blinking. */
  while(1) {
    GPIO_write_pin(GPIO_PORT_D, GPIO_PIN_12, 1);
    for(uint32_t i = 0; i < 550000; i++);
    GPIO_write_pin(GPIO_PORT_D, GPIO_PIN_12, 0);
    for(uint32_t i = 0; i < 550000; i++);
  }

  return;
}

/* A simple vista el código es el mismo. Al ser una configuracion open-drain, tenemos que el conjunto NMOS activo, y el PMOS desactivado. Esto lleva a a que solamente tengamos 2 estados de salida: GND y floating/indeterminado. Esto quiere decir que el sistema puede generar un valor de GND, pero no un VCC. Aquí tenemos 2 soluciones:

 * La primera consiste en emplear la resistencia pull-up del pin de salida. Con esto obtendremos que cuando estemos en un estado indeterminado, obtengamos el valor de VCC al que va conectado esta resistencia. El problema es que la resistencia pull-up tiene un valor muy alto, y el LED no sea capaz de brillar completamente.

 * La segunda consiste en dejar el circuito sin resistencias pull-up/down, pero conectar una resistencia pull-up EXTERNA. Esta tendrá un valor de 320/470 ohmios, y mediante cables obtendremos de la propia placa 5V (VCC). De este modo conseguiremos que el LED brille intensamente cuando hagamos el parpadeo.
*/

void ejercicio_2_configuracion_open_drain()
{
  /* Enables the module before configure, otherwise it won't work */
  GPIO_clock_enable_disable(GPIO_PORT_D, 1);

  /* Configure the GPIO port and pin. We're going to use a board's led,
   * so we need to see which port and pin are necessary. */
  GPIO_Initialization(GPIO_PORT_D, GPIO_PIN_12, GPIO_MODE_OUTPUT,
                         GPIO_NO_PULL_UP_DOWN, GPIO_OUTPUT_PUSH_PULL,
                         GPIO_SPEED_MEDIUM, GPIO_NON_ALTERNATE_FUNCTIONALITY,
                         0);

  /* Now, create a loop to blink the LED light with a sleep time between */
  while(1) {
    GPIO_write_pin(GPIO_PORT_D, GPIO_PIN_12, 1);
    for(uint32_t i = 0; i < 550000; i++);
    GPIO_write_pin(GPIO_PORT_D, GPIO_PIN_12, 0);
    for(uint32_t i = 0; i < 550000; i++);
  }
  return;
}

/* Ejercicio 3: escribir un programa en el que se ilumine un led cuando pulsemos el boton integrado de la placa. */
/* Lo primero consistirá en buscar el boton integrado de USER (hay dos en la placa, uno de RESET, y otro de USER), y ver que conexión tiene con el micro controlador. Para ello debemos mirar el esquemático de la placa, y ver donde está conectado. En este caso vemos que el botón se encuentra conectado al PA0 -> GPIO A, pin 0. */
void ejercicio_3()
{
  /* Enables the module before configure, otherwise it won't work */
  GPIO_clock_enable_disable(GPIO_PORT_A, 1);
  GPIO_clock_enable_disable(GPIO_PORT_D, 1);

  /* Configure the GPIO port and pin. We're going to use a board's led,
   * so we need to see which port and pin are necessary. */
  GPIO_Initialization(GPIO_PORT_D, GPIO_PIN_12, GPIO_MODE_OUTPUT,
                      GPIO_NO_PULL_UP_DOWN, GPIO_OUTPUT_PUSH_PULL,
                      GPIO_SPEED_MEDIUM, GPIO_NON_ALTERNATE_FUNCTIONALITY,
                      0);

  /* Configure the GPIO port and pin. We're going to use a board's led,
   * so we need to see which port and pin are necessary. */
  GPIO_Initialization(GPIO_PORT_A, GPIO_PIN_0, GPIO_MODE_INPUT,
                         GPIO_NO_PULL_UP_DOWN, GPIO_OUTPUT_PUSH_PULL,
                         GPIO_SPEED_MEDIUM, GPIO_NON_ALTERNATE_FUNCTIONALITY,
                         0);

  /* Now check the state of the buttons pin, and if it's pushs, light the led, otherwise turn it off */
  while(1) {
    if(GPIO_read_pin(GPIO_PORT_A, GPIO_PIN_0))
    {
      GPIO_write_pin(GPIO_PORT_D, GPIO_PIN_12, 1);
    } else {
      GPIO_write_pin(GPIO_PORT_D, GPIO_PIN_12, 0);
    }
  }

  return;
}

/* Ejercicio 4: escribir un programa que lea de un botón externo
 * a través de un puerto GPIO y que ilumine un LED externo cuando
 * el boton esté presionado. Los puertos GPIO deben ser PB12 para
 * el botón y PA8 para el LED. El LED externo debe llevar una
 * resistencia de 470 ohmios. */
void ejercicio_4()
{
  /* Enables the module before configure, otherwise it won't work */
  GPIO_clock_enable_disable(GPIO_PORT_A, 1);
  GPIO_clock_enable_disable(GPIO_PORT_B, 1);

  /* Configure the GPIO port and pin. We're going to use a board's led,
   * so we need to see which port and pin are necessary. */
  GPIO_Initialization(GPIO_PORT_A, GPIO_PIN_8, GPIO_MODE_OUTPUT,
                      GPIO_NO_PULL_UP_DOWN, GPIO_OUTPUT_PUSH_PULL,
                      GPIO_SPEED_MEDIUM, GPIO_NON_ALTERNATE_FUNCTIONALITY,
                      0);

  /* Configure the GPIO port and pin. We're going to use a board's led,
   * so we need to see which port and pin are necessary. */
  GPIO_Initialization(GPIO_PORT_B, GPIO_PIN_12, GPIO_MODE_INPUT,
                         GPIO_PULL_UP, GPIO_OUTPUT_PUSH_PULL,
                         GPIO_SPEED_MEDIUM, GPIO_NON_ALTERNATE_FUNCTIONALITY,
                         0);

  /* Now check the state of the buttons pin, and if it's pushs, light the led, otherwise turn it off */
  while(1) {
    if(GPIO_read_pin(GPIO_PORT_B, GPIO_PIN_12))
    {
      GPIO_write_pin(GPIO_PORT_A, GPIO_PIN_8, 0);
    } else {
      GPIO_write_pin(GPIO_PORT_A, GPIO_PIN_8, 1);
    }
  }

  return;
}

/* Ejercicio 5: conectar un botón a PD5 y que se encienda un LED, mediante una interrupción,
 * cuando se detecte un flanco de caída en la pulsación del botón. El LED puede ser uno de
 * los que vienen en la placa.*/
void ejercicio_5()
{

  GPIO_clock_enable_disable(GPIO_PORT_D, 1);

  /* Configure the GPIO port and pin. We're going to use a board's led,
   * so we need to see which port and pin are necessary. */
  GPIO_Initialization(GPIO_PORT_D, GPIO_PIN_5, GPIO_MODE_INT_FALLING,
                      GPIO_PULL_UP, GPIO_OUTPUT_PUSH_PULL,
                      GPIO_SPEED_MEDIUM, GPIO_NON_ALTERNATE_FUNCTIONALITY,
                      0xF);

  /* Configure the GPIO port and pin. We're going to use a board's led,
   * so we need to see which port and pin are necessary. */
  GPIO_Initialization(GPIO_PORT_D, GPIO_PIN_12, GPIO_MODE_OUTPUT,
                      GPIO_NO_PULL_UP_DOWN, GPIO_OUTPUT_PUSH_PULL,
                      GPIO_SPEED_MEDIUM, GPIO_NON_ALTERNATE_FUNCTIONALITY,
                      0);

  /* THis while is important, because if it is not include, the program will finish without make anyuthing. */
  while(1);

  return;
}

/* This is the Interrupt Handler routine to attend the interrupt of the EXIT9_5 group. Here is where the toggle of the pin must happen */
void EXTI9_5_IRQHandler(void)
{
	/* Este bucle se incluye para evitar el "rebote" del botón. */
	for(uint32_t i = 0; i < 550000; i++);
  /* Now check the state of the buttons pin, and if it's pushs, light the led, otherwise turn it off */
    if(GPIO_read_pin(GPIO_PORT_D, GPIO_PIN_12))
    {
      GPIO_write_pin(GPIO_PORT_D, GPIO_PIN_12, 0);
    } else {
      GPIO_write_pin(GPIO_PORT_D, GPIO_PIN_12, 1);
    }
    GPIO_IRQ_handling(GPIO_PIN_12);
}

int main()
{
  /* Initializes the GPIO module.*/
  GPIO_initialization_module();

  //ejercicio_1_configuracion_push_pull(); //OK
  //ejercicio_2_configuracion_open_drain(); //OK
  //ejercicio_3(); //OK
  //ejercicio_4(); //OK
  ejercicio_5();

  return 0;
}


